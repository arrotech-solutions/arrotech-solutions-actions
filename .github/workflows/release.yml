# =============================================================================
# Reusable Release Workflow
# =============================================================================
# This workflow automates the release process including:
# - Semantic versioning
# - Changelog generation
# - GitHub release creation
# - Asset publishing
#
# Usage in consuming repo:
#   jobs:
#     release:
#       uses: arrotech-solutions/arrotech-solutions-actions/.github/workflows/release.yml@main
#       with:
#         release-type: 'auto'
#       secrets:
#         RELEASE_TOKEN: ${{ secrets.GITHUB_TOKEN }}
# =============================================================================

name: Release

on:
  workflow_call:
    inputs:
      release-type:
        description: 'Release type: auto (from commits), major, minor, patch, or specific version'
        required: false
        type: string
        default: 'auto'
      prerelease:
        description: 'Create as pre-release'
        required: false
        type: boolean
        default: false
      prerelease-tag:
        description: 'Pre-release tag (alpha, beta, rc)'
        required: false
        type: string
        default: 'beta'
      generate-changelog:
        description: 'Auto-generate changelog from commits'
        required: false
        type: boolean
        default: true
      update-package-version:
        description: 'Update version in package.json/pyproject.toml'
        required: false
        type: boolean
        default: true
      create-github-release:
        description: 'Create GitHub release'
        required: false
        type: boolean
        default: true
      draft:
        description: 'Create as draft release'
        required: false
        type: boolean
        default: false
      assets-path:
        description: 'Path to release assets (glob pattern)'
        required: false
        type: string
        default: ''
      working-directory:
        description: 'Working directory'
        required: false
        type: string
        default: '.'
    outputs:
      version:
        description: 'Released version'
        value: ${{ jobs.release.outputs.version }}
      release-url:
        description: 'URL of the GitHub release'
        value: ${{ jobs.release.outputs.release-url }}
      changelog:
        description: 'Generated changelog content'
        value: ${{ jobs.release.outputs.changelog }}
    secrets:
      RELEASE_TOKEN:
        description: 'Token for creating releases (needs write permissions)'
        required: true

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.new-version }}
      release-url: ${{ steps.create-release.outputs.url }}
      changelog: ${{ steps.changelog.outputs.content }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current-version
        run: |
          # Try to get version from various sources
          VERSION=""
          
          # package.json
          if [ -f "package.json" ]; then
            VERSION=$(jq -r '.version' package.json)
          # pyproject.toml
          elif [ -f "pyproject.toml" ]; then
            VERSION=$(python3 -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])" 2>/dev/null || \
                     grep -E "^version\s*=" pyproject.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
          # Cargo.toml
          elif [ -f "Cargo.toml" ]; then
            VERSION=$(grep -E "^version\s*=" Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
          # Git tags
          else
            VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          fi
          
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Current version: $VERSION"

      - name: Calculate next version
        id: version
        env:
          CURRENT: ${{ steps.current-version.outputs.version }}
          RELEASE_TYPE_INPUT: ${{ inputs.release-type }}
          IS_PRERELEASE: ${{ inputs.prerelease }}
          PRERELEASE_TAG_INPUT: ${{ inputs.prerelease-tag }}
        run: |
          RELEASE_TYPE="$RELEASE_TYPE_INPUT"
          
          # Parse current version
          MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          MINOR=$(echo "$CURRENT" | cut -d. -f2)
          PATCH=$(echo "$CURRENT" | cut -d. -f3 | cut -d- -f1)
          
          if [ "$RELEASE_TYPE" = "auto" ]; then
            # Analyze commits to determine version bump
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD~100")
            COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s")
            
            if echo "$COMMITS" | grep -qE "^(feat|feature)!:|BREAKING CHANGE"; then
              RELEASE_TYPE="major"
            elif echo "$COMMITS" | grep -qE "^(feat|feature)"; then
              RELEASE_TYPE="minor"
            else
              RELEASE_TYPE="patch"
            fi
            
            echo "Auto-detected release type: $RELEASE_TYPE"
          fi
          
          # Calculate new version
          case "$RELEASE_TYPE" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              ;;
            *)
              # Specific version provided
              NEW_VERSION="$RELEASE_TYPE"
              ;;
          esac
          
          # Add prerelease tag if needed
          if [ "$IS_PRERELEASE" = "true" ]; then
            # Find next prerelease number
            EXISTING=$(git tag -l "v${NEW_VERSION}-${PRERELEASE_TAG_INPUT}.*" | wc -l)
            NEW_VERSION="${NEW_VERSION}-${PRERELEASE_TAG_INPUT}.$((EXISTING + 1))"
          fi
          
          echo "new-version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "New version: $NEW_VERSION"

      - name: Generate changelog
        id: changelog
        if: inputs.generate-changelog
        env:
          NEW_VERSION: ${{ steps.version.outputs.new-version }}
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            RANGE="$LAST_TAG..HEAD"
          else
            RANGE="HEAD~50..HEAD"
          fi
          
          # Generate changelog content
          CHANGELOG="## What's Changed in v$NEW_VERSION\n\n"
          
          # Group by type
          FEATURES=$(git log "$RANGE" --pretty=format:"- %s (%h)" --grep="^feat" || true)
          FIXES=$(git log "$RANGE" --pretty=format:"- %s (%h)" --grep="^fix" || true)
          DOCS=$(git log "$RANGE" --pretty=format:"- %s (%h)" --grep="^docs" || true)
          OTHERS=$(git log "$RANGE" --pretty=format:"- %s (%h)" --grep="^chore\|^refactor\|^perf\|^style\|^test\|^ci" || true)
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG="$CHANGELOG### ðŸš€ Features\n$FEATURES\n\n"
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="$CHANGELOG### ðŸ› Bug Fixes\n$FIXES\n\n"
          fi
          
          if [ -n "$DOCS" ]; then
            CHANGELOG="$CHANGELOG### ðŸ“š Documentation\n$DOCS\n\n"
          fi
          
          if [ -n "$OTHERS" ]; then
            CHANGELOG="$CHANGELOG### ðŸ”§ Other Changes\n$OTHERS\n\n"
          fi
          
          # Add contributors
          CONTRIBUTORS=$(git log "$RANGE" --pretty=format:"%an" | sort -u | tr '\n' ', ' | sed 's/,$//')
          CHANGELOG="$CHANGELOG### ðŸ‘¥ Contributors\n$CONTRIBUTORS\n"
          
          # Save to file
          echo -e "$CHANGELOG" > RELEASE_NOTES.md
          
          # Output for use in release
          {
            echo "content<<EOF"
            echo -e "$CHANGELOG"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Update package version (Node.js)
        if: inputs.update-package-version
        env:
          NEW_VERSION: ${{ steps.version.outputs.new-version }}
        run: |
          if [ -f "package.json" ]; then
            npm version "$NEW_VERSION" --no-git-tag-version --allow-same-version
            git add package.json package-lock.json 2>/dev/null || true
          fi

      - name: Update package version (Python)
        if: inputs.update-package-version
        env:
          NEW_VERSION: ${{ steps.version.outputs.new-version }}
        run: |
          if [ -f "pyproject.toml" ]; then
            sed -i "s/^version = .*/version = \"$NEW_VERSION\"/" pyproject.toml
            git add pyproject.toml
          fi

      - name: Commit version bump
        if: inputs.update-package-version
        env:
          NEW_VERSION: ${{ steps.version.outputs.new-version }}
        run: |
          git commit -m "chore(release): v$NEW_VERSION" --allow-empty
          git push

      - name: Create and push tag
        env:
          NEW_VERSION: ${{ steps.version.outputs.new-version }}
        run: |
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
          git push origin "v$NEW_VERSION"

      - name: Collect release assets
        id: assets
        if: inputs.assets-path != ''
        env:
          ASSETS_PATH: ${{ inputs.assets-path }}
        run: |
          ASSETS=$(find "$ASSETS_PATH" -type f 2>/dev/null | tr '\n' ',' | sed 's/,$//' || echo "")
          echo "files=$ASSETS" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        id: create-release
        if: inputs.create-github-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.new-version }}
          name: Release v${{ steps.version.outputs.new-version }}
          body_path: ${{ inputs.generate-changelog && 'RELEASE_NOTES.md' || '' }}
          draft: ${{ inputs.draft }}
          prerelease: ${{ inputs.prerelease }}
          files: ${{ inputs.assets-path }}
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Summary
        env:
          VERSION: ${{ steps.version.outputs.new-version }}
          RELEASE_TYPE: ${{ inputs.release-type }}
          IS_PRERELEASE: ${{ inputs.prerelease }}
          IS_DRAFT: ${{ inputs.draft }}
        run: |
          {
            echo "## ðŸŽ‰ Release Summary"
            echo ""
            echo "- **Version:** v$VERSION"
            echo "- **Type:** $RELEASE_TYPE"
            echo "- **Pre-release:** $IS_PRERELEASE"
            echo "- **Draft:** $IS_DRAFT"
            echo ""
            echo "### Changelog"
            cat RELEASE_NOTES.md || true
          } >> "$GITHUB_STEP_SUMMARY"


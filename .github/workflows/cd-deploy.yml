# =============================================================================
# Reusable Deployment Workflow
# =============================================================================
# This workflow handles deployments to various environments and platforms.
# Supports: Kubernetes, AWS ECS, Azure Container Apps, Vercel, Netlify, etc.
#
# Usage in consuming repo:
#   jobs:
#     deploy:
#       uses: arrotech-solutions/arrotech-solutions-actions/.github/workflows/cd-deploy.yml@main
#       with:
#         environment: 'staging'
#         platform: 'kubernetes'
#         image: 'ghcr.io/arrotech-solutions/my-app:sha-abc123'
#       secrets:
#         KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
# =============================================================================

name: Deployment

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment: development, staging, production'
        required: true
        type: string
      platform:
        description: 'Deployment platform: kubernetes, ecs, flyio, vercel, netlify, ssh'
        required: false
        type: string
        default: 'kubernetes'
      # Container/Image inputs
      image:
        description: 'Container image to deploy (full URL with tag/digest)'
        required: false
        type: string
        default: ''
      # Kubernetes inputs
      namespace:
        description: 'Kubernetes namespace'
        required: false
        type: string
        default: 'default'
      deployment-name:
        description: 'Kubernetes deployment name'
        required: false
        type: string
        default: ''
      helm-chart-path:
        description: 'Path to Helm chart (if using Helm)'
        required: false
        type: string
        default: ''
      helm-values-file:
        description: 'Path to Helm values file'
        required: false
        type: string
        default: ''
      kubectl-manifest-path:
        description: 'Path to Kubernetes manifests (if not using Helm)'
        required: false
        type: string
        default: ''
      # AWS ECS inputs
      ecs-cluster:
        description: 'ECS cluster name'
        required: false
        type: string
        default: ''
      ecs-service:
        description: 'ECS service name'
        required: false
        type: string
        default: ''
      ecs-task-definition:
        description: 'Path to ECS task definition file'
        required: false
        type: string
        default: ''
      aws-region:
        description: 'AWS region'
        required: false
        type: string
        default: 'us-east-1'
      # Vercel/Netlify inputs
      project-name:
        description: 'Project name for serverless platforms'
        required: false
        type: string
        default: ''
      build-command:
        description: 'Build command for serverless deployments'
        required: false
        type: string
        default: 'npm run build'
      output-directory:
        description: 'Output directory for serverless deployments'
        required: false
        type: string
        default: 'dist'
      # Vercel-specific inputs for preview/promote pattern
      vercel-deploy-mode:
        description: 'Vercel deploy mode: auto (default), preview (deploy to preview only), promote (promote latest to production)'
        required: false
        type: string
        default: 'auto'
      vercel-org-id:
        description: 'Vercel organization ID (optional, uses linked project if not set)'
        required: false
        type: string
        default: ''
      vercel-project-id:
        description: 'Vercel project ID (optional, uses linked project if not set)'
        required: false
        type: string
        default: ''
      vercel-preview-url:
        description: 'Preview URL to run tests against (output from preview deployment)'
        required: false
        type: string
        default: ''
      # SSH deployment inputs
      ssh-host:
        description: 'SSH host for direct deployment'
        required: false
        type: string
        default: ''
      ssh-user:
        description: 'SSH username'
        required: false
        type: string
        default: 'deploy'
      deploy-path:
        description: 'Remote path for deployment'
        required: false
        type: string
        default: '/var/www/app'
      # Fly.io inputs
      flyio-app-name:
        description: 'Fly.io application name'
        required: false
        type: string
        default: ''
      flyio-region:
        description: 'Fly.io deployment region (e.g., lhr, iad, sjc)'
        required: false
        type: string
        default: ''
      flyio-config-path:
        description: 'Path to fly.toml configuration file'
        required: false
        type: string
        default: 'fly.toml'
      flyio-dockerfile:
        description: 'Path to Dockerfile for Fly.io build'
        required: false
        type: string
        default: 'Dockerfile'
      flyio-build-args:
        description: 'Build arguments for Fly.io (space-separated KEY=VALUE pairs)'
        required: false
        type: string
        default: ''
      flyio-vm-size:
        description: 'Fly.io VM size (shared-cpu-1x, shared-cpu-2x, performance-1x, etc.)'
        required: false
        type: string
        default: 'shared-cpu-1x'
      flyio-vm-memory:
        description: 'Fly.io VM memory in MB'
        required: false
        type: number
        default: 256
      flyio-min-machines:
        description: 'Minimum number of Fly.io machines'
        required: false
        type: number
        default: 1
      flyio-max-machines:
        description: 'Maximum number of Fly.io machines for autoscaling'
        required: false
        type: number
        default: 1
      flyio-ha:
        description: 'Enable high availability (multiple machines in different regions)'
        required: false
        type: boolean
        default: false
      # Common inputs
      working-directory:
        description: 'Working directory'
        required: false
        type: string
        default: '.'
      wait-for-rollout:
        description: 'Wait for deployment rollout to complete'
        required: false
        type: boolean
        default: true
      rollout-timeout:
        description: 'Timeout for rollout wait (in seconds)'
        required: false
        type: number
        default: 600
      dry-run:
        description: 'Perform a dry run without actual deployment'
        required: false
        type: boolean
        default: false
    outputs:
      deployment-url:
        description: 'URL of the deployed application'
        value: ${{ jobs.deploy.outputs.url }}
      deployment-status:
        description: 'Status of the deployment'
        value: ${{ jobs.deploy.outputs.status }}
      preview-url:
        description: 'Vercel preview URL (for preview deployments)'
        value: ${{ jobs.deploy-vercel.outputs.preview-url }}
      deployment-id:
        description: 'Vercel deployment ID (for promoting later)'
        value: ${{ jobs.deploy-vercel.outputs.deployment-id }}
    secrets:
      KUBE_CONFIG:
        description: 'Kubeconfig file contents (base64 encoded)'
        required: false
      AWS_ACCESS_KEY_ID:
        description: 'AWS Access Key ID'
        required: false
      AWS_SECRET_ACCESS_KEY:
        description: 'AWS Secret Access Key'
        required: false
      VERCEL_TOKEN:
        description: 'Vercel API token'
        required: false
      NETLIFY_AUTH_TOKEN:
        description: 'Netlify authentication token'
        required: false
      SSH_PRIVATE_KEY:
        description: 'SSH private key for direct deployment'
        required: false
      FLY_API_TOKEN:
        description: 'Fly.io API token for deployment'
        required: false
      DEPLOY_ENV_VARS:
        description: 'Environment variables for deployment (JSON format)'
        required: false

jobs:
  # ---------------------------------------------------------------------------
  # Pre-deployment Checks
  # ---------------------------------------------------------------------------
  pre-check:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.validate.outputs.proceed }}
    steps:
      - name: Validate inputs
        id: validate
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          PLATFORM: ${{ inputs.platform }}
          DRY_RUN: ${{ inputs.dry-run }}
        run: |
          echo "Environment: $ENVIRONMENT"
          echo "Platform: $PLATFORM"
          echo "Dry run: $DRY_RUN"
          
          # Production deployment warnings
          if [ "$ENVIRONMENT" = "production" ]; then
            echo "::warning::Production deployment detected. Ensure all approvals are in place."
          fi
          
          echo "proceed=true" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # Kubernetes Deployment
  # ---------------------------------------------------------------------------
  deploy-kubernetes:
    name: Deploy to Kubernetes
    if: inputs.platform == 'kubernetes'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Setup Helm
        if: inputs.helm-chart-path != ''
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy with Helm
        id: helm-deploy
        if: inputs.helm-chart-path != ''
        env:
          DEPLOYMENT_NAME: ${{ inputs.deployment-name || github.event.repository.name }}
          CHART_PATH: ${{ inputs.helm-chart-path }}
          NAMESPACE: ${{ inputs.namespace }}
          IMAGE: ${{ inputs.image }}
          VALUES_FILE: ${{ inputs.helm-values-file }}
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          ROLLOUT_TIMEOUT: ${{ inputs.rollout-timeout }}
        run: |
          # Build helm command with proper quoting
          DRY_RUN_FLAG=""
          if [ "$DRY_RUN_MODE" = "true" ]; then
            DRY_RUN_FLAG="--dry-run"
          fi
          
          helm upgrade --install "$DEPLOYMENT_NAME" "$CHART_PATH" \
            --namespace "$NAMESPACE" \
            --set "image=$IMAGE" \
            ${VALUES_FILE:+-f "$VALUES_FILE"} \
            $DRY_RUN_FLAG \
            --wait --timeout "${ROLLOUT_TIMEOUT}s"

      - name: Deploy with kubectl
        id: kubectl-deploy
        if: inputs.kubectl-manifest-path != '' && inputs.helm-chart-path == ''
        env:
          MANIFEST_PATH: ${{ inputs.kubectl-manifest-path }}
          IMAGE: ${{ inputs.image }}
          NAMESPACE: ${{ inputs.namespace }}
          DRY_RUN_MODE: ${{ inputs.dry-run }}
        run: |
          # Update image in manifests
          if [ -n "$IMAGE" ]; then
            find "$MANIFEST_PATH" \( -name "*.yaml" -o -name "*.yml" \) -exec \
              sed -i "s|image:.*|image: $IMAGE|g" {} +
          fi
          
          DRY_RUN=""
          if [ "$DRY_RUN_MODE" = "true" ]; then
            DRY_RUN="--dry-run=client"
          fi
          
          kubectl apply -f "$MANIFEST_PATH" -n "$NAMESPACE" $DRY_RUN

      - name: Update deployment image
        id: deploy
        if: inputs.deployment-name != '' && inputs.helm-chart-path == '' && inputs.kubectl-manifest-path == ''
        env:
          DEPLOYMENT_NAME: ${{ inputs.deployment-name }}
          IMAGE: ${{ inputs.image }}
          NAMESPACE: ${{ inputs.namespace }}
          DRY_RUN_MODE: ${{ inputs.dry-run }}
        run: |
          DRY_RUN=""
          if [ "$DRY_RUN_MODE" = "true" ]; then
            DRY_RUN="--dry-run=client"
          fi
          
          kubectl set image "deployment/$DEPLOYMENT_NAME" \
            "$DEPLOYMENT_NAME=$IMAGE" \
            -n "$NAMESPACE" $DRY_RUN
          
          echo "status=initiated" >> "$GITHUB_OUTPUT"

      - name: Wait for rollout
        if: inputs.wait-for-rollout && !inputs.dry-run
        env:
          DEPLOYMENT_NAME: ${{ inputs.deployment-name || github.event.repository.name }}
          NAMESPACE: ${{ inputs.namespace }}
          ROLLOUT_TIMEOUT: ${{ inputs.rollout-timeout }}
        run: |
          kubectl rollout status "deployment/$DEPLOYMENT_NAME" \
            -n "$NAMESPACE" \
            --timeout="${ROLLOUT_TIMEOUT}s"
          
          echo "status=completed" >> "$GITHUB_OUTPUT"

      - name: Get service URL
        if: "!inputs.dry-run"
        id: get-url
        env:
          SERVICE_NAME: ${{ inputs.deployment-name || github.event.repository.name }}
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          URL=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || \
                kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || \
                echo "")
          echo "url=$URL" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # AWS ECS Deployment
  # ---------------------------------------------------------------------------
  deploy-ecs:
    name: Deploy to AWS ECS
    if: inputs.platform == 'ecs'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws-region }}

      - name: Update ECS task definition
        id: task-def
        if: inputs.ecs-task-definition != ''
        env:
          TASK_DEF_FILE: ${{ inputs.ecs-task-definition }}
          IMAGE: ${{ inputs.image }}
        run: |
          # Update image in task definition
          TASK_DEF=$(cat "$TASK_DEF_FILE")
          TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "$IMAGE" '.containerDefinitions[0].image = $IMAGE')
          echo "$TASK_DEF" > task-definition-updated.json
          
          # Register new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition --cli-input-json file://task-definition-updated.json)
          TASK_DEF_ARN=$(echo "$NEW_TASK_DEF" | jq -r '.taskDefinition.taskDefinitionArn')
          echo "task-def-arn=$TASK_DEF_ARN" >> "$GITHUB_OUTPUT"

      - name: Deploy to ECS
        id: deploy
        env:
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          ECS_CLUSTER: ${{ inputs.ecs-cluster }}
          ECS_SERVICE: ${{ inputs.ecs-service }}
          TASK_DEF_ARN: ${{ steps.task-def.outputs.task-def-arn || inputs.ecs-task-definition }}
        run: |
          if [ "$DRY_RUN_MODE" = "true" ]; then
            echo "Dry run - would deploy to ECS cluster $ECS_CLUSTER"
            echo "status=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --task-definition "$TASK_DEF_ARN" \
            --force-new-deployment
          
          echo "status=initiated" >> "$GITHUB_OUTPUT"

      - name: Wait for deployment
        if: inputs.wait-for-rollout && !inputs.dry-run
        env:
          ECS_CLUSTER: ${{ inputs.ecs-cluster }}
          ECS_SERVICE: ${{ inputs.ecs-service }}
        run: |
          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE"
          
          echo "status=completed" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # Vercel Deployment
  # ---------------------------------------------------------------------------
  # Supports three modes via vercel-deploy-mode:
  #   - auto: Deploy preview for non-production, production for production env
  #   - preview: Always deploy to preview URL (for testing before promote)
  #   - promote: Promote latest preview deployment to production
  # ---------------------------------------------------------------------------
  deploy-vercel:
    name: Deploy to Vercel
    if: inputs.platform == 'vercel'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url || steps.promote.outputs.url }}
      status: ${{ steps.deploy.outputs.status || steps.promote.outputs.status }}
      preview-url: ${{ steps.deploy.outputs.preview-url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Configure Vercel project
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ inputs.vercel-org-id }}
          VERCEL_PROJECT_ID: ${{ inputs.vercel-project-id }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          # Set org/project IDs if provided
          if [ -n "$VERCEL_ORG_ID" ] && [ -n "$VERCEL_PROJECT_ID" ]; then
            echo "VERCEL_ORG_ID=$VERCEL_ORG_ID" >> "$GITHUB_ENV"
            echo "VERCEL_PROJECT_ID=$VERCEL_PROJECT_ID" >> "$GITHUB_ENV"
          fi
          
          # Pull Vercel environment configuration
          vercel pull --yes --environment="$ENVIRONMENT" --token="$VERCEL_TOKEN"

      - name: Build project
        if: inputs.vercel-deploy-mode != 'promote'
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          DEPLOY_MODE: ${{ inputs.vercel-deploy-mode }}
          IS_PRODUCTION: ${{ inputs.environment == 'production' }}
        run: |
          # For 'preview' mode, always build without --prod
          # For 'auto' mode, build based on environment
          if [ "$DEPLOY_MODE" = "preview" ]; then
            echo "Building for preview deployment..."
            vercel build --token="$VERCEL_TOKEN"
          elif [ "$IS_PRODUCTION" = "true" ]; then
            echo "Building for production deployment..."
            vercel build --prod --token="$VERCEL_TOKEN"
          else
            echo "Building for staging/development..."
            vercel build --token="$VERCEL_TOKEN"
          fi

      - name: Deploy to Vercel
        id: deploy
        if: inputs.vercel-deploy-mode != 'promote'
        env:
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          DEPLOY_MODE: ${{ inputs.vercel-deploy-mode }}
          IS_PRODUCTION: ${{ inputs.environment == 'production' }}
        run: |
          if [ "$DRY_RUN_MODE" = "true" ]; then
            echo "Dry run - would deploy to Vercel"
            echo "status=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Determine deployment type
          if [ "$DEPLOY_MODE" = "preview" ]; then
            # Preview mode: always deploy to preview URL, never to production
            echo "Deploying to preview URL..."
            DEPLOY_OUTPUT=$(vercel deploy --prebuilt --token="$VERCEL_TOKEN" 2>&1)
            DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | tail -1)
            
            # Extract deployment ID from URL
            DEPLOYMENT_ID=$(echo "$DEPLOY_URL" | sed 's|https://||' | cut -d'.' -f1)
            
            echo "url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
            echo "preview-url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
            echo "deployment-id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
            echo "status=preview-deployed" >> "$GITHUB_OUTPUT"
            
            echo "âœ… Preview deployed: $DEPLOY_URL"
            echo "ðŸ“‹ Deployment ID: $DEPLOYMENT_ID"
            echo ""
            echo "To promote to production after tests pass, use:"
            echo "  vercel promote $DEPLOY_URL --token=\$VERCEL_TOKEN"
            
          elif [ "$IS_PRODUCTION" = "true" ]; then
            # Auto mode + production: deploy directly to production
            echo "Deploying to production..."
            DEPLOY_URL=$(vercel deploy --prebuilt --prod --token="$VERCEL_TOKEN")
            echo "url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
            echo "status=completed" >> "$GITHUB_OUTPUT"
            
          else
            # Auto mode + non-production: deploy to preview
            echo "Deploying to preview (staging/development)..."
            DEPLOY_URL=$(vercel deploy --prebuilt --token="$VERCEL_TOKEN")
            echo "url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
            echo "preview-url=$DEPLOY_URL" >> "$GITHUB_OUTPUT"
            echo "status=completed" >> "$GITHUB_OUTPUT"
          fi

      - name: Promote to Production
        id: promote
        if: inputs.vercel-deploy-mode == 'promote'
        env:
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          if [ "$DRY_RUN_MODE" = "true" ]; then
            echo "Dry run - would promote to production"
            echo "status=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "Promoting latest deployment to production..."
          
          # Get the latest deployment URL and promote it
          LATEST_DEPLOYMENT=$(vercel list --token="$VERCEL_TOKEN" --limit=1 2>/dev/null | tail -1 | awk '{print $1}')
          
          if [ -n "$LATEST_DEPLOYMENT" ]; then
            # Promote using vercel alias or by redeploying with --prod
            PROD_URL=$(vercel promote "$LATEST_DEPLOYMENT" --token="$VERCEL_TOKEN" 2>&1 || vercel --prod --token="$VERCEL_TOKEN")
            echo "url=$PROD_URL" >> "$GITHUB_OUTPUT"
            echo "status=promoted" >> "$GITHUB_OUTPUT"
            echo "âœ… Promoted to production: $PROD_URL"
          else
            echo "::error::No deployment found to promote"
            exit 1
          fi

      - name: Output deployment summary
        if: always()
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url || steps.promote.outputs.url }}
          PREVIEW_URL: ${{ steps.deploy.outputs.preview-url }}
          DEPLOY_MODE: ${{ inputs.vercel-deploy-mode }}
          STATUS: ${{ steps.deploy.outputs.status || steps.promote.outputs.status }}
        run: |
          {
            echo "## Vercel Deployment Summary"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Mode | $DEPLOY_MODE |"
            echo "| Status | $STATUS |"
            echo "| URL | $DEPLOY_URL |"
            if [ -n "$PREVIEW_URL" ]; then
              echo "| Preview URL | $PREVIEW_URL |"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

  # ---------------------------------------------------------------------------
  # Netlify Deployment
  # ---------------------------------------------------------------------------
  deploy-netlify:
    name: Deploy to Netlify
    if: inputs.platform == 'netlify'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.deploy-url }}
      status: ${{ steps.set-status.outputs.status }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies and build
        env:
          BUILD_COMMAND: ${{ inputs.build-command }}
        run: |
          npm ci
          eval "$BUILD_COMMAND"

      - name: Deploy to Netlify
        id: deploy
        uses: nwtgck/actions-netlify@v3
        with:
          publish-dir: ${{ inputs.output-directory }}
          production-deploy: ${{ inputs.environment == 'production' }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Deploy from GitHub Actions - ${{ github.sha }}"
          enable-pull-request-comment: true
          enable-commit-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ inputs.project-name }}

      - name: Set deployment status
        id: set-status
        if: always()
        env:
          DEPLOY_OUTCOME: ${{ steps.deploy.outcome }}
        run: |
          if [ "$DEPLOY_OUTCOME" = "success" ]; then
            echo "status=completed" >> "$GITHUB_OUTPUT"
          else
            echo "status=failed" >> "$GITHUB_OUTPUT"
          fi

  # ---------------------------------------------------------------------------
  # Fly.io Deployment
  # ---------------------------------------------------------------------------
  deploy-flyio:
    name: Deploy to Fly.io
    if: inputs.platform == 'flyio'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      status: ${{ steps.deploy.outputs.status }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Check Fly.io app exists
        id: check-app
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
        run: |
          if flyctl apps list | grep -q "^$APP_NAME "; then
            echo "app-exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "app-exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Fly.io app (if not exists)
        if: steps.check-app.outputs.app-exists == 'false' && !inputs.dry-run
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
          REGION: ${{ inputs.flyio-region }}
        run: |
          if [ -n "$REGION" ]; then
            flyctl apps create "$APP_NAME" --org personal -r "$REGION"
          else
            flyctl apps create "$APP_NAME" --org personal
          fi

      - name: Set Fly.io secrets
        if: "!inputs.dry-run"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
          DEPLOY_ENV_VARS: ${{ secrets.DEPLOY_ENV_VARS }}
        run: |
          if [ -n "$DEPLOY_ENV_VARS" ]; then
            echo "$DEPLOY_ENV_VARS" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while read -r line; do
              flyctl secrets set "$line" -a "$APP_NAME" || true
            done
          fi

      - name: Deploy to Fly.io
        id: deploy
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
          CONFIG_PATH: ${{ inputs.flyio-config-path }}
          DOCKERFILE: ${{ inputs.flyio-dockerfile }}
          BUILD_ARGS: ${{ inputs.flyio-build-args }}
          REGION: ${{ inputs.flyio-region }}
          VM_SIZE: ${{ inputs.flyio-vm-size }}
          VM_MEMORY: ${{ inputs.flyio-vm-memory }}
          HA_MODE: ${{ inputs.flyio-ha }}
          WAIT_FOR_ROLLOUT: ${{ inputs.wait-for-rollout }}
        run: |
          if [ "$DRY_RUN_MODE" = "true" ]; then
            echo "Dry run - would deploy to Fly.io app: $APP_NAME"
            echo "status=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Build fly deploy command
          DEPLOY_CMD="flyctl deploy"
          DEPLOY_CMD="$DEPLOY_CMD --app $APP_NAME"
          DEPLOY_CMD="$DEPLOY_CMD --config $CONFIG_PATH"
          DEPLOY_CMD="$DEPLOY_CMD --dockerfile $DOCKERFILE"
          DEPLOY_CMD="$DEPLOY_CMD --vm-size $VM_SIZE"
          DEPLOY_CMD="$DEPLOY_CMD --vm-memory $VM_MEMORY"
          
          # Add region if specified
          if [ -n "$REGION" ]; then
            DEPLOY_CMD="$DEPLOY_CMD --region $REGION"
          fi
          
          # Add HA mode
          if [ "$HA_MODE" = "true" ]; then
            DEPLOY_CMD="$DEPLOY_CMD --ha"
          fi
          
          # Add wait flag
          if [ "$WAIT_FOR_ROLLOUT" = "true" ]; then
            DEPLOY_CMD="$DEPLOY_CMD --wait-timeout 300"
          else
            DEPLOY_CMD="$DEPLOY_CMD --detach"
          fi
          
          # Add build args
          if [ -n "$BUILD_ARGS" ]; then
            for arg in $BUILD_ARGS; do
              DEPLOY_CMD="$DEPLOY_CMD --build-arg $arg"
            done
          fi
          
          # Execute deployment
          eval "$DEPLOY_CMD"
          
          # Get deployment URL
          URL=$(flyctl info -a "$APP_NAME" --json | jq -r '.Hostname // empty')
          if [ -n "$URL" ]; then
            echo "url=https://$URL" >> "$GITHUB_OUTPUT"
          fi
          echo "status=completed" >> "$GITHUB_OUTPUT"

      - name: Get deployment status
        if: "!inputs.dry-run"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
        run: |
          echo "Checking deployment status..."
          flyctl status -a "$APP_NAME"
          
          echo ""
          echo "Machine list:"
          flyctl machines list -a "$APP_NAME"

      - name: Scale machines
        if: "!inputs.dry-run && inputs.flyio-min-machines > 1"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ inputs.flyio-app-name || github.event.repository.name }}
          MIN_MACHINES: ${{ inputs.flyio-min-machines }}
          MAX_MACHINES: ${{ inputs.flyio-max-machines }}
        run: |
          flyctl scale count "$MIN_MACHINES" --max "$MAX_MACHINES" -a "$APP_NAME" || true

  # ---------------------------------------------------------------------------
  # SSH Deployment
  # ---------------------------------------------------------------------------
  deploy-ssh:
    name: Deploy via SSH
    if: inputs.platform == 'ssh'
    needs: pre-check
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      status: ${{ steps.deploy.outputs.status }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_HOST: ${{ inputs.ssh-host }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts

      - name: Deploy via SSH
        id: deploy
        env:
          DRY_RUN_MODE: ${{ inputs.dry-run }}
          SSH_HOST: ${{ inputs.ssh-host }}
          SSH_USER: ${{ inputs.ssh-user }}
          DEPLOY_PATH: ${{ inputs.deploy-path }}
        run: |
          if [ "$DRY_RUN_MODE" = "true" ]; then
            echo "Dry run - would deploy via SSH to $SSH_HOST"
            echo "status=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Sync files
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key" \
            --exclude '.git' \
            --exclude 'node_modules' \
            --exclude '.env*' \
            ./ "${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/"
          
          # Restart application (customize based on your setup)
          ssh -i ~/.ssh/deploy_key "${SSH_USER}@${SSH_HOST}" "cd $DEPLOY_PATH && ./deploy.sh" || true
          
          echo "status=completed" >> "$GITHUB_OUTPUT"

  # ---------------------------------------------------------------------------
  # Summary
  # ---------------------------------------------------------------------------
  deploy:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes, deploy-ecs, deploy-flyio, deploy-vercel, deploy-netlify, deploy-ssh]
    if: always()
    outputs:
      url: ${{ needs.deploy-kubernetes.outputs.url || needs.deploy-ecs.outputs.url || needs.deploy-flyio.outputs.url || needs.deploy-vercel.outputs.url || needs.deploy-netlify.outputs.url || needs.deploy-ssh.outputs.url }}
      status: ${{ needs.deploy-kubernetes.outputs.status || needs.deploy-ecs.outputs.status || needs.deploy-flyio.outputs.status || needs.deploy-vercel.outputs.status || needs.deploy-netlify.outputs.status || needs.deploy-ssh.outputs.status }}
    steps:
      - name: Deployment summary
        env:
          K8S_RESULT: ${{ needs.deploy-kubernetes.result }}
          ECS_RESULT: ${{ needs.deploy-ecs.result }}
          FLYIO_RESULT: ${{ needs.deploy-flyio.result }}
          VERCEL_RESULT: ${{ needs.deploy-vercel.result }}
          NETLIFY_RESULT: ${{ needs.deploy-netlify.result }}
          SSH_RESULT: ${{ needs.deploy-ssh.result }}
        run: |
          {
            echo "## Deployment Summary"
            echo ""
            echo "| Platform | Status |"
            echo "|----------|--------|"
            echo "| Kubernetes | $K8S_RESULT |"
            echo "| AWS ECS | $ECS_RESULT |"
            echo "| Fly.io | $FLYIO_RESULT |"
            echo "| Vercel | $VERCEL_RESULT |"
            echo "| Netlify | $NETLIFY_RESULT |"
            echo "| SSH | $SSH_RESULT |"
          } >> "$GITHUB_STEP_SUMMARY"

